#define WRITE_SINGLE_COMMAND(num) do{                   \
    commandCount++;                                     \
    fprintf(outputTextFile, "%d\n", (num));             \
    write_char_to_buffer(&binBuffer, num);              \
                                                        \
}while(0)

#define JUMP_ASSEMBLER(jmp_type) {                                              \
    commandCount++;                                                             \
    fprintf(outputTextFile, "%d ", jmp_type);                                   \
                                                                                \
    if ((error = write_char_to_buffer(&binBuffer, jmp_type)))                   \
    {                                                                           \
        break;                                                                  \
    }                                                                           \
                                                                                \
    int tagIp = -1;                                                             \
    if (sscanf(text->linesPtr[i], "%s %d", command, &tagIp) == 2)               \
    {                                                                           \
        fprintf(outputTextFile, "%d\n", tagIp);                                 \
                                                                                \
        if ((error = write_int_to_buffer(&binBuffer, tagIp)))                   \
        {                                                                       \
            break;                                                              \
        }                                                                       \
        continue;                                                               \
    }                                                                           \
                                                                                \
    char tagName[MAX_COMMAND_LEN] = {};                                         \
                                                                                \
    if (sscanf(text->linesPtr[i], "%s %s", command, tagName) != 2)              \
    {                                                                           \
        error = INVALID_SYNTAX;                                                 \
        print_assembler_error(error, text->linesPtr[i], i+1);                   \
        break;                                                                  \
    }                                                                           \
                                                                                \
    tagIp = -1;                                                                 \
    get_tag_ip(tagBuffer, tagName, &tagIp);                                     \
                                                                                \
    fprintf(outputTextFile, "%d\n", tagIp);                                     \
                                                                                \
    if ((error = write_int_to_buffer(&binBuffer, tagIp)))                       \
    {                                                                           \
        break;                                                                  \
    }                                                                           \
}

#define JUMP_PROCESSOR                                                                  \
    processor->IP++;                                                                    \
                                                                                        \
    int newIp = -1;                                                                     \
    if (copy_data_from_buffer(processor->CS + processor->IP, &newIp, sizeof(int)))      \
    {                                                                                   \
        RETURN(COPU_ARG_ERROR);                                                         \
    }                                                                                   


DEF_CMD("jmp", JMP, 1, 
    JUMP_ASSEMBLER(JMP), 
    {
        JUMP_PROCESSOR

        err = processor_jmp(processor, newIp);
    }
    )

DEF_CMD("ja", JA, 1,
JUMP_ASSEMBLER(JA),
{
    JUMP_PROCESSOR

    err = processor_ja(processor, newIp);
})

DEF_CMD("jae", JAE, 1,
JUMP_ASSEMBLER(JAE),
{
    JUMP_PROCESSOR

    err = processor_jae(processor, newIp);
})

DEF_CMD("jb", JB, 1,
JUMP_ASSEMBLER(JB),
{
    JUMP_PROCESSOR

    err = processor_jb(processor, newIp);
})

DEF_CMD("jbe", JBE, 1,
JUMP_ASSEMBLER(JBE),
{
    JUMP_PROCESSOR

    err = processor_jbe(processor, newIp);
})

DEF_CMD("je", JE, 1,
JUMP_ASSEMBLER(JE),
{
    JUMP_PROCESSOR

    err = processor_je(processor, newIp);
})

DEF_CMD("jne", JNE, 1,
JUMP_ASSEMBLER(JNE),
{
    JUMP_PROCESSOR

    err = processor_jne(processor, newIp);
})

#undef JUMP_ASSEMBLER

DEF_CMD("push", PUSH, 1, 
    {
        commandCount++;
        char cmd = 0;

        if(sscanf(text->linesPtr[i], "%s %lf", command, &commandArg) == 2)
        {
            cmd |= (PUSH | IMM);

            fprintf(outputTextFile, "17 %lf\n", commandArg);

            if ((error = write_char_to_buffer(&binBuffer, cmd)))
            {
                break;
            }

            if ((error = write_double_to_buffer(&binBuffer, commandArg)))
            {
                break;
            }
        }

        else if (sscanf(text->linesPtr[i], "%s %s", command, registerName) == 2)
        {
            cmd |= (PUSH | REG);

            registerNames reg = NO_REG;

            fprintf(outputTextFile, "33 ");

            if ((error = write_char_to_buffer(&binBuffer, cmd)))
            {
                break;
            }

            if (registerName[0] == 'r' && registerName[2] == 'x')
            {
                switch (registerName[1])
                {
                case 97:
                    reg = RAX;
                    break;
                case 98:
                    reg = RBX;
                    break;
                case 99:
                    reg = RCX;
                    break;
                case 100:
                    reg = RDX;
                    break;
                
                default:
                    error = WRONG_REGISTER_NAME;
                    print_assembler_error(error, text->linesPtr[i], i+1);
                    break;
                }
            }
            else
            {
                error = INVALID_SYNTAX;
                print_assembler_error(error, text->linesPtr[i], i+1);
                break;
            }

            if (error) break;

            fprintf(outputTextFile, "%d\n", reg);

            if ((error = write_char_to_buffer(&binBuffer, reg)))
            {
                break;
            }
        }

        else
        {
            error = INVALID_SYNTAX;
            print_assembler_error(error, text->linesPtr[i], i+1);
            break;
        }
    }, 
    {
        processor->IP++;

        if ((int) command == (PUSH | IMM))
        {
            if (copy_data_from_buffer(processor->CS + processor->IP, &commandArg, sizeof(double)))
            {
                RETURN(COPU_ARG_ERROR);
            }

            err = processor_push(commandArg, &(processor->stack));

            processor->IP += 8;
        }
        else if ((int) command == (PUSH | REG))
        {
            reg = (registerNames) *(processor->CS + processor->IP);

            err = processor_push_from_register(processor, reg);

            processor->IP++;
        }
    }
    )

DEF_CMD("pop", POP, 1, 
    {
        commandCount++;
        if (sscanf(text->linesPtr[i], "%s %s", command, registerName) != 2)
        {
            error = INVALID_SYNTAX;
            print_assembler_error(error, text->linesPtr[i], i+1);
            break;
        }

        char cmd = 0;

        cmd |= (POP | REG);

        registerNames reg = NO_REG;

        fprintf(outputTextFile, "45 ");

        if ((error = write_char_to_buffer(&binBuffer, cmd)))
        {
            break;
        }

        if (registerName[0] == 'r' && registerName[2] == 'x')
        {
            switch (registerName[1])
            {
            case 97:
                reg = RAX;
                break;
            case 98:
                reg = RBX;
                break;
            case 99:
                reg = RCX;
                break;
            case 100:
                reg = RDX;
                break;
            
            default:
                    error = WRONG_REGISTER_NAME;
                    print_assembler_error(error, text->linesPtr[i], i+1);
                    break;
                }
        }
        else
        {
            error = INVALID_SYNTAX;
            print_assembler_error(error, text->linesPtr[i], i+1);
            break;
        }

        if (error) break;

        fprintf(outputTextFile, "%d\n", reg);

        if ((error = write_char_to_buffer(&binBuffer, reg)))
        {
            break;
        }
    }, 
    processor->IP++;

    if ((int) command == (POP | REG))
    {
        reg = (registerNames) *(processor->CS + processor->IP);

        err = processor_pop(processor, reg);

        processor->IP++;
    }
    )

DEF_CMD("add", ADD, 0, 
    {
        WRITE_SINGLE_COMMAND(ADD);
    },
    err = processor_add(&(processor->stack));
    processor->IP++;
    )

DEF_CMD("sub", SUB, 0, 
    {
        WRITE_SINGLE_COMMAND(SUB);
    },
    err = processor_sub(&(processor->stack));
    processor->IP++;
    )

DEF_CMD("mul", MUL, 0, 
    {
        WRITE_SINGLE_COMMAND(MUL);
    },
    err = processor_mul(&(processor->stack));
    processor->IP++;
    )

DEF_CMD("div", DIV, 0, 
    {
        WRITE_SINGLE_COMMAND(DIV);
    },
    err = processor_div(&(processor->stack));
    processor->IP++;
    )

DEF_CMD("out", OUT, 0, 
    {
        WRITE_SINGLE_COMMAND(OUT);
    },
    err = processor_out(&(processor->stack), stdout);
    processor->IP++;
    )

DEF_CMD("sqrt", SQRT, 0, 
    {
        WRITE_SINGLE_COMMAND(SQRT);
    },
    err = processor_sqrt(&(processor->stack));
    processor->IP++;
    )

DEF_CMD("sin", SIN, 0, 
    {
        WRITE_SINGLE_COMMAND(SIN);
    },
    err = processor_trig(&(processor->stack), command);
    processor->IP++;
    )

DEF_CMD("cos", COS, 0, 
    {
        WRITE_SINGLE_COMMAND(COS);
    },
    err = processor_trig(&(processor->stack), command);
    processor->IP++;
    )

DEF_CMD("tan", TAN, 0, 
    {
        WRITE_SINGLE_COMMAND(TAN);
    },
    err = processor_trig(&(processor->stack), command);
    processor->IP++;
    )

DEF_CMD("in", IN, 0, 
    {
        WRITE_SINGLE_COMMAND(IN);
    },
    err = processor_in(&(processor->stack));
    processor->IP++;
    )

DEF_CMD("hlt", HLT, 0, 
    {
        WRITE_SINGLE_COMMAND(HLT);
    },
    err = processor_hlt(&(processor->stack));
    processor->IP++;
    RETURN(NO_PROCESSOR_ERRORS);
    )

#undef WRITE_SINGLE_COMMAND
